import { Request, Response } from "express";
import { CS } from "./context.service";
import { Error403, Error500, GenError } from "../utils/errors/errors";
import { IDeletedCreatedData } from "../object-format-controller/dtd-declarer.dtd";
import { LibModelClass, uniqueSlugNameNoColon } from "../utils/enums";
import moment from 'moment';
import { AuthHelperService } from "./auth-helper.service";
import { Db, ObjectId } from "mongodb";
import { FetchableField } from "../object-format-controller/fetchable-field";
import { RequestQueryParams, RequestQueryParamsParsed } from "./request-handler.helper/dtd";
import to from "await-to-js";

export class RequestHelperService {

	public static isIdServerTask(id: string | ObjectId) {
		if (!id)
			return false;

		if (AuthHelperService.SERVER_TASK_OBJECT_ID.includes(id as any))
			return true;

		if (AuthHelperService.SERVER_TASK_OBJECT_ID.includes(id.toString()))
			return true;

		if (AuthHelperService.SERVER_TASK_OBJECT_ID.includes((id as any).id))
			return true;

		return false;
	}

	/**
	 * Searches the object by doing a lowercase check of the key and the authheader
	 * @param obj the object where to search the authorization header property
	 */
	public static findHeaderKeyValue(obj: object, key: string): string {
		return obj[Object.keys(obj).find(k => k.toLowerCase() === key.toLowerCase())] || '';
	}

	/**
	 * Parses the query string into its proper format
	 * @throws if there are errors in format
	 */
	public static parseQueryStrings(req: Request) {
		// const toSet: RequestQueryParamsParsed = {};
		req.qsParsed = {};
		req.qs = req.query as any;

		// throw the key name in this block
		try {
			const qs: RequestQueryParams = req.query as any;
			
			// parse JSON
			const obj: (keyof RequestQueryParamsParsed)[] = ['fetch', 'filter', 'options', 'projection', 'sort'];
			obj.forEach((k: keyof RequestQueryParamsParsed) => {
				if (qs[k]) {
					try { 
						req.qsParsed[k] = JSON.parse(qs[k]) as never; 
					} catch (e) { 
						throw k; 
					}
				}
			});

			// parse numbers
			const num: (keyof RequestQueryParamsParsed)[] = ['limit', 'skip'];
			num.forEach(k => {
				if (qs[k]) {
					const int = parseInt(qs[k]);
					if (Number.isSafeInteger(int)) {
						req.qsParsed[k] = int as never;
					} else {
						throw k;
					}
				}
			});

			// parse bools
			const bool: (keyof RequestQueryParamsParsed)[] = ['getCount'];
			bool.forEach(k => {
				if (qs[k]) {
					const str = qs[k].toString();
					if (str === 'false') {
						req.qsParsed[k] = false as never;
					} else if (str === 'true') {
						req.qsParsed[k] = true as never;
					} else {
						throw k;
					}
				}
			});

		}
		// catch the throwed key and emit a proper error
		catch (e) {
			throw new Error403("Invalid query string types or Encoded incorrectly. key: " + e);
		}

	}

	/**
	 * Creates a req object that has every permission and locations
	 * 
	 * used for cron/sync etc
	 */
	// public static createBeJwtToken(slug: string, userId?: string) {
	// 	const body: DecodedAuthzToken = {
	// 		iss: moment().unix(), 
	// 		exp: false, 
	// 		slug: slug,
	// 		user: { 
	// 			_id: userId || RequestHelperService.SERVER_TASK_OBJECT_ID, 
	// 			name: RequestHelperService.SERVER_TASK_OBJECT_ID, 
	// 			att: [1], 
	// 			locs: ['*'],
	// 		}
	// 	};

	// 	const jwt = AuthHelperService.createJwt(body).jwtString;
	// 	return {
	// 		string: "Bearer " + jwt,
	// 		headers: {[AuthHelperService.AuthHeader]: "Bearer " + jwt},
	// 	}
	// }


	/**
	 * checks if a req object is generated by the backend
	 */
	public static isReqFromBackend(req: Request): boolean {
		const auth = AuthHelperService.getAuthzBody(req);
		if (!auth) 
			return false;

		return AuthHelperService.SERVER_TASK_OBJECT_ID.includes(auth.userId)
	}

	/**
	 * Reponds to a FE request with an error given
	 */
	public static async respondWithError(res: Response, givenErr: any) {
		// change type
		let err: GenError = givenErr as any;

		// TODO manage better Fetch Error
		// TODO manage array of errors too (array of axios error etc)

		// try parsing the message
		let parsedMessage: object;
		try { parsedMessage = JSON.parse(err.message); } 
		catch (e) {}
		
		// check if error is a gen error, otherwise cast it
		if (!err.status) { 
			const newErr = new Error500(err.message || err);
			newErr.stack = err.stack || newErr.stack;
			err = newErr;
		}
		
		// add the exception to the DB
		// and return only the excpetion id
		if (err.status === 500 && err.message) {
			const [oof, id] = await to(CS.addException(res.req, err));
			if (oof) {
				console.log(oof); 
				return this.sendRes(res, 500, {trace: null, error: err});
			}
			
			this.sendRes(res, 500, {trace: id, message: 'Unexpected Error', error: err});
		}
		else {
			// send error
			this.sendRes(res, err.status, parsedMessage || err.message);
		}
	}

	/**
	 * sends the response only if not already sent :D
	 */
	private static sendRes(res: Response, status: number, message?: any) {
		if (!res.headersSent) {
			res.status(status).send(message);
		}
	}

	/**
	 * Returns the object to use in the _deleted field
	 */
	public static getCreatedDeletedObject(req: Request): IDeletedCreatedData {
		return {
			_timestamp: moment().unix(), 
			_author: new FetchableField( 
				AuthHelperService.getUserIdFromToken(req), 
				LibModelClass.User,
			),
		};
	}


	/**
	 * Returns the key slug used by a client
	 */
	public static getSlugByRequest(req: Request): string {
		if (req.__stlse_req && req.__stlse_req.instanceId)
			return req.__stlse_req.instanceId;

		const inUrl = req.params[uniqueSlugNameNoColon];
		if (inUrl)
			return inUrl;

		throw new Error('Could not find slug for request: ' + req.url);
	}

	/**
	 * Returns the db of a client by its slug
	 */
	public static getClientDbBySlug(reqOrSlug: Request): Db {
		return CS.db.db(reqOrSlug);
	}

	/**
	 * Allows you to safely throw inside an express handler instead of manully calling RequestHelperService.respondWithError();
	 * @param fn An express handler
	 */
	public static safeHandler(fn: (req: Request, res: Response, next?: () => void) => Promise<any> | any): ((req: Request, res: Response, next: () => void) => Promise<any> | any) {
		return async (req, res, next) => {

			// allow for the safe Handler to be used as a middleware
			// by flagging if the next() was used
			// if so then the returned value from the function is not sent to the user
			// but ignored
			let nextUsed = false;
			const nextMW = () => { nextUsed = true; next(); }

			try {
				// resolve function given by the user
				let r = fn(req, res, nextMW);
				
				// resolve promise
				if (r instanceof Promise) 
					r = await r;

				// resolve normal return
				return !res.headersSent && !nextUsed && res.send(r);
			} 
			catch (e) {
				RequestHelperService.respondWithError(res, e);
			}
		};
	}

}
