import { Component } from 'react';
import { FormGroup, AbstractControl, FormArray, FormControl, Validators, ValidatorFn } from 'react-reactive-form';
import { Observable } from 'rxjs';
import { ObjectUtils } from '@sixempress/utilities';
import { LoadingOverlay } from '../loading-overlay/loading-overlay';
import { IPatchOperation, FetchableField, IMongoDBFetch } from '../../services/controllers/dtd';
import { AbstractEditorState, AbstractEditorConfig, AbstractEditorProps, editorComponentId } from './dtd/abstract-editor.dtd';
import { ErrorFactory } from '../../utils/errors/error-factory';
import { Helpers } from '../../utils/various/helpers';
import { SmallUtils } from '@sixempress/utilities';
import { AuthService } from '../../services/authentication/authentication';
import { LibAttribute } from '../../utils/enums/default-enums.enum';
import { TopLevelEditorPart, DividerPart, IEditorLogicPart } from './dtd/editor-parts.dtd';
import { BaseField } from './dtd/fields.dtd';
import { RouterService } from '../../services/router/router-service';
import { IBaseModel } from '../../services/controllers/IBaseModel';
import { BusinessLocationsService } from '../../services/business/business-locations.service';
import { ModalComponentProps } from '@sixempress/theme';
import { RouteComponentProps } from '@sixempress/theme';
import { AbstractDbItemController } from '../../services/controllers/abstract-db-item.controller';
import { ControllerQueryOpts } from '../../services/controllers/controllers.dtd';

export abstract class AbstractEditorLogic<T extends IBaseModel, P = {}, S extends Partial<AbstractEditorState<T>> = {}> extends Component<AbstractEditorProps<T> & ModalComponentProps & RouteComponentProps & P, AbstractEditorState<T> & S> {

	abstract controller: AbstractDbItemController<T>;

	state = {} as AbstractEditorState<T> & S;

	/**
	 * saves the action subscribed until it is complete
	 * so that if the user presses twice save. it wont save twice
	 */
	protected currentlySending = false;

	/**
	 * TRUE => Generates field WITH required validator
	 * UNDEFINED => Generates the field WITHOUTH required validator
	 * FALSE => does NOT generate the field
	 */
	protected requirePhysicalLocation: boolean = undefined;

	/**
	 * TRUE => Generates field WITH required validator
	 * UNDEFINED => Generates the field WITHOUTH required validator
	 * FALSE => does NOT generate the field
	 */
	protected requireDocumentLocation: boolean = true;
	/**
	 * TRUE => Generates field WITH required validator
	 * UNDEFINED => Generates the field WITHOUTH required validator
	 * FALSE => does NOT generate the field
	 */
	protected requireDocumentLocationsFilter: boolean = undefined;

	/**
	 * The object received from the BE when an editor is opened in "Modify" mode
	 */
	protected objFromBe: T | undefined;

	/**
	 * An array of fields to fetch from the queried object
	 */
	protected fieldsToFetch?: IMongoDBFetch<T>[];

	cache: {
		/**
		 * The settings generated by the component that extends this abstract
		 */
		editorSettings?: TopLevelEditorPart<T>[];
	} = {};


	/**
	 * The configuration of the abstract editor
	 */
	protected config: AbstractEditorConfig<T> = {
		idToModify: this.props.editorComponentId || RouterService.match(this.props)[this.props.routeIdParamName || editorComponentId],
		// this.router.navigate(['../'], { relativeTo: this.route.parent });
		onSaveSuccess: (beResponse: T | T[], id?: string) => {
			if (this.props.modalRef) {
				this.props.modalRef.close();
			} else {
				RouterService.back();
			}
		},
		onSaveError: (error: any) => { 
			throw error; 
		},
		...this.getEditorConfiguration(),
		...this.props,
	};

	/**
	 * Returns configuration that are used to override the default configuration
	 */
	protected getEditorConfiguration(): AbstractEditorProps<T> { 
		return {}; 
	}
	
	/**
	 * Generates the form group with starting data based on the input
	 * @param val the data to modify. leave empty if you want to create an empty form group
	 */
	protected abstract generateEditorSettings(val?: T): TopLevelEditorPart<T>[];


	/**
	 * Set initial data once the component is mounted
	 */
	componentDidMount() {
		// update the state once the form group is generated
		this.setInitialData().subscribe();
	}

	forceUpdate() {
		super.forceUpdate();
		this.fullFormGroupValidation();
	}

	/**
	 * Resolves to undefined when no item was found
	 * Resolves to the ITEM to modify if found
	 */
	protected getEditorRelativeItem(id?: string): Observable<T | undefined> {

		// if not in edit mode, then return undefined
		if (!id) { return new Observable(obs_ => obs_.next()); }

		// return the query of the lement
		const opts: ControllerQueryOpts<T> = {};
		if (this.fieldsToFetch && this.fieldsToFetch.length !== 0) {
			opts.params = { fetch: this.fieldsToFetch };
		}
		
		return new Observable((obs) => {
			this.controller.getSingle(id, opts)
			.then(r => (obs.next(r), obs.complete()))
			.catch(e => obs.error(e));
		});
	}

	/**
	 * Generates the formGroup
	 * if there is an ID in the url, queries the relative user,
	 * else creates an empty form group
	 */
	protected setInitialData(): Observable<void> {
		return new Observable(obs => {
			
			this.getEditorRelativeItem(this.config.idToModify).subscribe(res => {
				// objFromBE is undefined if in add mode
				this.objFromBe = res;

				// get the editor settings
				const editorSettings = this.generateEditorSettings(res);

				this.addFields(editorSettings);

				Helpers.checkAttributes(editorSettings);

				this.validateEditorSettings(editorSettings);

				const formGroup = this.generateFormGroup(this.objFromBe, editorSettings);

				// validate when the full form group is generated
				this.fullFormGroupValidation(formGroup);

				this.cache.editorSettings = editorSettings;

				this.setState(
					{...this.state, formGroup},
					() => {
						obs.next();
						obs.complete();
					}
				);

			});

		});
	}

	/**
	 * Adds documentLocation and documentLocationsFilter if needed
	 * if they are not needed it adds them as abstractControl as to always have the field present in the formGroup.value
	 */
	protected addFields(editorSettings: TopLevelEditorPart<T>[]) {

		// get values for the fields
		const docPhyLoc = BusinessLocationsService.getDocPosSelectValues(this.objFromBe && this.objFromBe.physicalLocation);
		const docPosVal = BusinessLocationsService.getDocPosSelectValues(this.objFromBe && this.objFromBe.documentLocation);
		const docVisVal = BusinessLocationsService.getDocVisSelectValues(this.objFromBe && this.objFromBe.documentLocationsFilter);
		
		
		// if the places available are more than 1
		const addPhyLoc = this.requirePhysicalLocation === true && docPhyLoc.length !== 1;
		// if the places available are more than 1
		const addDocLoc = this.requireDocumentLocation !== false && docPosVal.length !== 1;
		// if the places available are more than 1, and if add mode, or modify mode (with the right attrs)
		const addDocFilLoc = this.requireDocumentLocationsFilter !== false && docVisVal.length !== 1 && (
			(!this.objFromBe) ||
			(this.objFromBe && AuthService.isAttributePresent(LibAttribute.canChangeDocLocFilter))
		);
		
		// if a divide is already added, then dont add
		const dividerAdded = editorSettings.length !== 0 && (
			editorSettings[editorSettings.length - 1].type === 'divider' || 
			editorSettings[editorSettings.length - 1].type === 'cut'
		);

		const size = addDocLoc && addDocFilLoc && addPhyLoc ? 4 : 6;

		if (!dividerAdded && (addDocLoc || addDocFilLoc || addPhyLoc))
			editorSettings.push({type: "divider"} as DividerPart<T>);

		const valPhyLoc = this.objFromBe
			? this.objFromBe.physicalLocation
			: BusinessLocationsService.chosenLocationId;

		if (addPhyLoc) {
			editorSettings.push({
				type: 'formControl',
				gridProp: {md: size},
				logic: {
					key: 'physicalLocation',
					component: 'SelectField',
					label: "Posizione Fisica",
					value: valPhyLoc,
					required: this.requirePhysicalLocation,
					values: docPhyLoc
				}
			});
		}
		else if (this.requirePhysicalLocation !== false) {
			editorSettings.unshift({
				type: 'abstractControl',
				logic: {key: 'physicalLocation', control: new FormControl(valPhyLoc)}
			});
		}

		const valDocLoc = this.objFromBe
			? this.objFromBe.documentLocation
			: BusinessLocationsService.chosenLocationId;

		if (addDocLoc) {
			editorSettings.push({
				type: 'formControl',
				gridProp: {md: size},
				logic: {
					key: 'documentLocation',
					component: 'SelectField',
					label: "Creato in",
					value: valDocLoc,
					required: this.requireDocumentLocation,
					values: docPosVal
				}
			});
		}
		else if (this.requireDocumentLocation !== false) {
			editorSettings.unshift({
				type: 'abstractControl',
				logic: {key: 'documentLocation', control: new FormControl(valDocLoc)}
			});
		}
		
		const valDocLocFil = this.objFromBe
			? this.objFromBe.documentLocationsFilter
			: BusinessLocationsService.chosenLocationId 
				? [BusinessLocationsService.chosenLocationId] 
				: AuthService.isAttributePresent(LibAttribute.canSetGlobalLocFilter)
					? ["*"]
					: [];

		if (addDocFilLoc) {
			editorSettings.push({
				type: 'formControl',
				gridProp: {md: size},
				logic: {
					key: 'documentLocationsFilter',
					component: 'MultiSelectField',
					label: "Visibilita' elemento",
					values: docVisVal,
					value: valDocLocFil,
					required: this.requireDocumentLocationsFilter,
					validators: Validators.required,
				}
			});
		} 
		else if (this.requireDocumentLocationsFilter !== false) {
			editorSettings.unshift({
				type: 'abstractControl',
				logic: {key: 'documentLocationsFilter', control: new FormControl(valDocLocFil)}
			});
		}


	}

	/**
	 * returns the key to use for the formGroup
	 * @returns undefined = if the setting given not a logc control
	 * @returns string = it's the key to use in when you want to retrieve a formControl (formGroup.get({THIS_STRING}))
	 */
	protected getCurrKey(sett: TopLevelEditorPart<any>, recursivePath: string = ''): undefined | string {
		if (sett.type === 'cut' || sett.type === 'jsx' || sett.type === 'divider') { return; }

		// if child of formaray
		// and the child will not be an object
		// then return itself broder
		if (
			// has a formArray parent
			sett.parent && sett.parent.type === 'formArray' && 
			// is not forced a formGroup
			!sett.parent.logic.forceFormGroup && 
			// and there is only 1 logic part
			sett.parent.logic.parts.filter(e => ['abstractControl', 'formGroup', 'formControl', 'formArray'].indexOf(e.type) !== -1).length === 1
		) {
			return recursivePath;
		}

		// else build the path to the key
		return recursivePath ? recursivePath + '.' + sett.logic.key : sett.logic.key;
	}

	/**
	 * 1) Checks that the are no keys duplicate
	 * 2) removes undefined || null values from array
	 * 3) references the parent in the child editorSettings
	 */
	private validateEditorSettings(editorSettings: TopLevelEditorPart<any>[], recursivePath: string = '', parent?: TopLevelEditorPart<any>): void {
		const keys = [];

		// TODO deep keys not analyzying proplety
		for (let i = 0; i < editorSettings.length; i++) {
			const sett = editorSettings[i];

			// reference the parent
			if (parent) { sett.parent = parent; }

			// get the key of the part
			const currKey = this.getCurrKey(sett, recursivePath);

			// check if not null
			if (currKey) {
				// check if present
				if (keys.indexOf(currKey) !== -1) {
					throw ErrorFactory.make('Duplicate key found: "' + currKey + '"');
				} else {
					keys.push(currKey);
				}
			}

			// recursive check
			if (sett.type === 'formArray' || sett.type === 'formGroup') {
				this.validateEditorSettings(sett.logic.parts, currKey, sett);
			}

		}
	}


	protected generateFormGroup(beObj: T, editorSettings: TopLevelEditorPart<T>[]) {
		return new FormGroup(this.generateDataForAbstractControl(beObj, editorSettings));
	}

	/**
	 * Generates the form group from the editor setting
	 */
	protected generateDataForAbstractControl(objValue: any, editorSettings: TopLevelEditorPart<any>[], recursivePath: string = ''): {[key: string]: AbstractControl} {
		
		const car: {[key: string]: AbstractControl} = {};
		
		for (const obj of editorSettings) {
			
			// skip useless stuff
			if (obj.type === 'divider' || obj.type === 'jsx' || obj.type === 'cut') { continue; }

			const currKey = this.getCurrKey(obj, recursivePath);
			const validators = this.getValidatorsFromEditorPart(obj);

			// add the objects to the carry
			switch (obj.type) {
				case 'abstractControl':
					car[obj.logic.key] = obj.logic.control;
					break;

				case 'formGroup':
					car[obj.logic.key] = new FormGroup(this.generateDataForAbstractControl(objValue, obj.logic.parts, currKey), validators);
					break;

				case 'formArray':
					
					// set the gen function if not present
					if (!obj.logic.generateControl) {
						obj.logic.generateControl = (v?: any) => {
							
							// generate automatically the data to put inside the formarray
							const generated = this.generateDataForAbstractControl(obj.logic.getRowValueForControl ? obj.logic.getRowValueForControl(v) : v, obj.logic.parts);
							// quickcly check if there is a manual formArray control fn
							// and replace the automatic value with the manual one
							for (const p of obj.logic.parts) {
								const log = (p as IEditorLogicPart<T>).logic; 
								if (log && (p as IEditorLogicPart<T>).logic.controlFnFormArray) {
									generated[log.key] = log.controlFnFormArray(v); 
								}
							}
		
							// collapse the object to just a single abstractControl
							if (Object.keys(generated).length === 1 && !obj.logic.forceFormGroup) {
								return generated[Object.keys(generated)[0]];
							} 
							// else create the formGroup
							else {
								return new FormGroup(generated);
							}
						};
					}

					// set the value of the array
					const objArr: any[] = ObjectUtils.getValueByDotNotation(objValue, currKey) || [];
					
					// fill to required min with values
					if (objArr.length < obj.logic.min) {
						for (let i = objArr.length; i < obj.logic.min; i++) { 
							objArr.push(undefined); 
						}
					}

					// generate the formArray values
					car[obj.logic.key] = new FormArray(objArr.map(v => obj.logic.generateControl(v)));

					break;


				case 'formControl':

					// the value for this control
					const val = 
					// use given values
					typeof (obj.logic as BaseField).value !== 'undefined' && (obj.logic as BaseField).value !== null
						? (obj.logic as BaseField).value 
					
					// get value by notation
					: currKey 
						? ObjectUtils.getValueByDotNotation(objValue, currKey) 

					// use given value
					: objValue;

					car[obj.logic.key] = new FormControl(val, validators);
					break;
			}

			// if manual control is present, then skip
			// we do this AFTER the switch because if the obj is a formArray
			// then we need to generate the "generateControl" fn
			// and fill it to min and probably other different actions
			// so leave it here at the bottom
			if (obj.logic.control) {
				car[obj.logic.key] = obj.logic.control;
			}

		}
		
		return car;

	}

	/**
	 * @returns the validators to use when createing a new AbstracController by reading the editor conf given
	 */
	private getValidatorsFromEditorPart(obj: IEditorLogicPart<any>): ValidatorFn | ValidatorFn[] {
		
		const validators: ValidatorFn[] = [];

		// add automatic validators
		if (obj.type === 'formControl') {
			if (obj.logic.component === 'PriceField') { 
				validators.push(Validators.pattern(SmallUtils.fullPriceRegex)); 
			}
			else if (obj.logic.component === 'NumberField') {
				validators.push(Validators.pattern(/^[0-9]*$/));
				if (obj.logic.min) { validators.push(Validators.min(obj.logic.min)); }
				if (obj.logic.max) { validators.push(Validators.max(obj.logic.max)); }
			}
		}

		// add the manual validators
		if (((obj as IEditorLogicPart<any>).logic as BaseField).validators) {
			const vals = ((obj as IEditorLogicPart<any>).logic as BaseField).validators;
			if (vals.constructor === Array) {
				validators.push(...vals as ValidatorFn[]);
			} else {
				validators.push(vals as ValidatorFn);
			}
		}

		// add the required one if not present
		if (
			((obj as IEditorLogicPart<any>).logic as BaseField).required && 
			!validators.includes(Validators.required)
		) {
			validators.push(Validators.required);
		}

		// collparse the validators array
		return validators.length > 1 ? validators : validators[0];
	}



	/**
	 * A middleware that changes the data of the object to save
	 */
	protected generateToSaveObjectByFormGroup?(body: T): false | void | T | Observable<T>;

	/**
	 * Returns the cloned formGroup Value
	 * and calss the middleware "generateToSaveObjectByFormGroup" to change the data 
	 */
	protected getObjectToSave(): Observable<T> {
		return new Observable(obs => {
			const toSave = ObjectUtils.cloneDeep(this.state.formGroup.value) as T;
			
			// no modification yeet back
			if (!this.generateToSaveObjectByFormGroup) { 
				return obs.next(toSave);
			}
			
			// execute middleware
			const sub = this.generateToSaveObjectByFormGroup(toSave);
			// if obs, then sub
			if (sub instanceof Observable) { sub.subscribe(r => obs.next(r)); } 
			// if not obs, but got a return value then give that val
			else if (sub) { obs.next(sub); }
			// if the item doesnt return, then yeet back the object
			// if no return the modification are done by reference
			//
			// if it's false then dont returns at all
			else if (sub !== false) { obs.next(toSave); }

		});
	}


	/**
	 * Fixes the object and prepares it to send it to BE
	 */
	protected fixObjBeforeSend(obj: T): void {
		// if not present
		if (!obj.documentLocationsFilter) {
			// then set it to the documentLocation present
			if (obj.documentLocation) {
				obj.documentLocationsFilter = [obj.documentLocation];
			}
		}
		// if present and has a wildcard value, use that value then
		else if (obj.documentLocationsFilter.includes('*'))  {
			obj.documentLocationsFilter = ['*'];
		}			

		// if in MODIFY mode, then dont remove null || undefined fields
		// as they are used to build the $unset operations
		this.removeFieldsForBe(obj, !this.objFromBe || this.config.usePut);
	}

	/**
	 * Clears fetched fields, nullish fields recursevly
	 */
	private removeFieldsForBe(obj: any, removeNullish: boolean) {

		// clear ALWAYS array from nulls
		if (Array.isArray(obj)) {
			for (let i = 0; i < obj.length; i++) {
				if (obj[i] === null || obj[i] === undefined) {
					obj.splice(i, 1);
					i--;
				}
			}
		}

		for (const key in obj) {
			
			// removes fetched fields
			if ((obj as FetchableField<any>).fetched && (obj as FetchableField<any>).id && (obj as FetchableField<any>).modelClass) {
				delete (obj as FetchableField<any>).fetched;
			}

			if (removeNullish && (obj[key] === null || obj[key] === undefined)) {
				delete obj[key];
			} 
			else if (typeof obj[key] === 'object') {
				this.removeFieldsForBe(obj[key], removeNullish);
			}

		}
	}

	/**
	 * Generates the patchoperation to execute for the modified model by comparing the old one
	 * and the new modified one
	 */
	protected generatePatchOp(oldObject: T, newObject: T): Array<IPatchOperation<T>> {
		
		const patchOps: Array<IPatchOperation<T>> = [];
		
		// create a diference obj with be and fe objects
		const diff = ObjectUtils.objectDifference(oldObject, newObject, {returnFullArray: true});

		if (diff) {
			const toIter = ObjectUtils.objToPathAndValueHM(diff, false, true);
			for (const key in toIter) {

				// ignore special fields
				if (
					// if a fetched diff (could happen if it's not cleared or something)
					key.indexOf('.fetched') !== -1 || 
					// if a patch on an private field inside object
					(key as string).match(/(([^a-z]|^)_(?!id$|modelClass$))/i) || 
					// if a patch on a root private field
					key.indexOf('_') === 0
				) {
					continue;
				}

				// set or unset based on path value
				if (toIter[key] === undefined || toIter[key] === null) {
					patchOps.push({op: 'unset', path: key as keyof T, value: ""});
				} else {
					patchOps.push({op: 'set', path: key as keyof T, value: toIter[key]});
				}

			}
		}

		return patchOps;
	}

	/**
	 * Recusevily checks all the formgroup controlss
	 * 
	 * This function is used when the full formgroup is generated the first time
	 * (as some custom controls need control.parent)
	 * 
	 * And is used before saving the data
	 * 
	 * It also can work as a forceUpdate()
	 */
	protected fullFormGroupValidation(control: AbstractControl = this.state.formGroup) {
		if ((control as FormGroup).controls) {
			const group = (control as FormGroup);

			for (const field in group.controls) {
				const c = group.controls[field];

				this.fullFormGroupValidation(c);
			}
		}

		control.updateValueAndValidity({ onlySelf: true });
	}

	/**
	 * Saves the user to the Database
	 */
	protected send(): Observable<string> {
		if (this.currentlySending)
			return new Observable(o => {});

		this.currentlySending = true;
		return new Observable<string>(obs => {
			
			// continues only if formgroup is valid
			this.fullFormGroupValidation();
			if (!this.state.formGroup.valid) {
				return;
			}

			// sets the text on the loading overlay
			LoadingOverlay.text = 'Salvataggio in corso...';

			// generates the object to save or the patch operations to give
			this.getObjectToSave().subscribe(toSave => {
				
				this.fixObjBeforeSend(toSave);

				let action: Promise<any> = Promise.resolve();

				if (!this.objFromBe) {
					action = this.getSendAction('POST', toSave);
				}
				else if (this.config.usePut) {
					action = this.getSendAction('PUT', toSave);
				}
				else {
					action = this.getSendAction('PATCH', toSave); 
				}

				// execute the request
				action
				.then(success => {
					this.currentlySending = false;
					const id = success && success._id ? success._id : this.config.idToModify;
					this.config.onSaveSuccess(success, id);

					obs.next(id);
					obs.complete();
				})
				.catch(error => { 
					this.currentlySending = false;
					this.config.onSaveError(error);
				});

			});
		});
	}

	/**
	 * Returns the send action to use
	 */
	protected async getSendAction(mode: 'POST' | 'PUT' | 'PATCH', toSave: T): Promise<any> {

		switch (mode) {
			case 'POST':
				return this.controller.post(toSave);

			case 'PATCH':
				const patchOps = this.generatePatchOp(this.objFromBe, toSave);
				if (patchOps.length !== 0) { 
					return this.controller.patch(this.config.idToModify, patchOps);
				}
				break;

			case 'PUT':
				if (ObjectUtils.objectDifference(toSave, this.objFromBe)) {
					return this.controller.put(this.config.idToModify, toSave);
				}
				break;
			}
	}

}
